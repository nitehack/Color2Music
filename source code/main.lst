CCS PCM C Compiler, Version 4.104, 5967               03-ene.-15 15:45

               Filename: C:\Users\Ali\Documents\GitHub\Color2Music\source code\main.lst

               ROM used: 1368 words (33%)
                         Largest free fragment is 2048
               RAM used: 46 (12%) at main() level
                         90 (24%) worst case
               Stack:    4 worst case (3 in main + 1 for interrupts)

*
0000:  MOVLW  04
0001:  MOVWF  0A
0002:  GOTO   4CC
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   7F,W
0009:  MOVWF  20
000A:  MOVF   0A,W
000B:  MOVWF  27
000C:  CLRF   0A
000D:  SWAPF  20,F
000E:  MOVF   04,W
000F:  MOVWF  22
0010:  MOVF   77,W
0011:  MOVWF  23
0012:  MOVF   78,W
0013:  MOVWF  24
0014:  MOVF   79,W
0015:  MOVWF  25
0016:  MOVF   7A,W
0017:  MOVWF  26
0018:  BCF    03.7
0019:  BCF    03.5
001A:  BTFSS  0B.4
001B:  GOTO   01E
001C:  BTFSC  0B.1
001D:  GOTO   02F
001E:  MOVF   22,W
001F:  MOVWF  04
0020:  MOVF   23,W
0021:  MOVWF  77
0022:  MOVF   24,W
0023:  MOVWF  78
0024:  MOVF   25,W
0025:  MOVWF  79
0026:  MOVF   26,W
0027:  MOVWF  7A
0028:  MOVF   27,W
0029:  MOVWF  0A
002A:  SWAPF  21,W
002B:  MOVWF  03
002C:  SWAPF  7F,F
002D:  SWAPF  7F,W
002E:  RETFIE
002F:  BCF    0A.3
0030:  GOTO   031
.................... #include "main.h" 
.................... #include <16F88.h> 
.................... //////// Standard Header file for the PIC16F88 device //////////////// 
.................... #device PIC16F88 
.................... #list 
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES INTRC_IO                 //Internal RC Osc, no CLKOUT 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES MCLR                     //Master Clear pin enabled 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES RESERVED                 //Used to set the reserved FUSE bits 
.................... #FUSES CCPB3                    // Ponemos este fuse para que el PWM salga por la patilla 9 ya que  por defecto está en la 6 y esa ya se usa 
....................  
.................... #use delay(clock=8000000) 
*
005D:  MOVLW  61
005E:  MOVWF  04
005F:  BCF    03.7
0060:  MOVF   00,W
0061:  BTFSC  03.2
0062:  GOTO   070
0063:  MOVLW  02
0064:  MOVWF  78
0065:  CLRF   77
0066:  DECFSZ 77,F
0067:  GOTO   066
0068:  DECFSZ 78,F
0069:  GOTO   065
006A:  MOVLW  97
006B:  MOVWF  77
006C:  DECFSZ 77,F
006D:  GOTO   06C
006E:  DECFSZ 00,F
006F:  GOTO   063
0070:  RETURN
....................  
....................  
.................... #include "sound.c" 
.................... //Con esta libreria se pueden generar sonidos 
.................... //La función genera sonido esta ya calculada para un reloj de 8 MHz para el rango  
.................... // de frecuencias que nos interesa para esta aplicación. 
.................... //Habria que hacer una función más general. 
....................  
.................... #IFNDEF SIn 
.................... #define SIn 126 
.................... #define LABn 133 
.................... #define LAn 141 
.................... #define SOLBn 150 
.................... #define SOLn 159 
.................... #define FABn 168 
.................... #define FAn 178 
.................... #define MIn 189 
.................... #define REBn 200 
.................... #define REn 212 
.................... #define DOBn 225 
.................... #define DOn 238 
.................... #define NONE 0 
.................... #define ntime 1000 
.................... #ENDIF 
....................  
.................... void init_sound(){ 
....................    setup_ccp1(CCP_PWM); //Indicamos que queremos usar el PWM 
*
0055:  BSF    03.5
0056:  BCF    06.3
0057:  BCF    03.5
0058:  BCF    06.3
0059:  MOVLW  0C
005A:  MOVWF  17
.................... } 
005B:  BCF    0A.3
005C:  GOTO   513 (RETURN)
....................  
.................... void genera_sonido(int8 sonido){ 
....................    int16 value; 
....................    if(sonido!=0){ 
....................       value=(4*((int16)sonido+1))/2; 
....................       setup_timer_2(T2_DIV_BY_16, sonido ,4);  
....................       set_pwm1_duty(value); //se establece el ciclo de trabajo 
....................    } 
....................    else{ 
....................       set_pwm1_duty(0); 
....................    } 
.................... } 
....................  
.................... #include "color.c" 
.................... /* 
.................... Los pines que se indican en los "defines" son del sensor TCS3200 yl-64 
.................... */ 
.................... #include "frequency.c" 
.................... int16 tiempo=0; 
.................... //Esta librería mide la frecuencia de una señal que entr por RB0 
.................... #INT_EXT 
.................... void llega_pulso(void) { 
....................    tiempo=get_timer1(); // 
*
0031:  MOVF   0F,W
0032:  MOVWF  7A
0033:  MOVF   0E,W
0034:  MOVWF  77
0035:  MOVF   0F,W
0036:  SUBWF  7A,W
0037:  BTFSS  03.2
0038:  GOTO   031
0039:  MOVF   77,W
003A:  MOVWF  28
003B:  MOVF   7A,W
003C:  MOVWF  29
....................    set_timer1(0); //reinicia para nuevo pulso 
003D:  CLRF   0F
003E:  CLRF   0E
.................... } 
....................  
003F:  BCF    0B.1
0040:  BCF    0A.3
0041:  GOTO   01E
.................... void init_freq(){ 
....................    ext_int_edge(0,L_TO_H); //Flanco ascendente 
0042:  BSF    03.5
0043:  BSF    01.6
....................    enable_interrupts(INT_EXT); 
0044:  BCF    03.5
0045:  BSF    0B.4
....................    clear_interrupt(INT_EXT); //Borramos el flag 
0046:  BCF    0B.1
....................    enable_interrupts(GLOBAL); 
0047:  MOVLW  C0
0048:  IORWF  0B,F
....................    setup_timer_1(T1_INTERNAL | T1_DIV_BY_4);//para llegar a medir frecuencias bajas 
0049:  MOVLW  A5
004A:  MOVWF  10
.................... } 
....................  
.................... int16 calcula_frecuencia(){ 
....................    int16 tiempo_cal; 
....................    int16 frecuencia; 
....................    tiempo_cal=tiempo*2; //Es 4ciclos*T*4 del preescaler*ELm timer 
*
00AD:  BCF    03.0
00AE:  RLF    28,W
00AF:  MOVWF  63
00B0:  RLF    29,W
00B1:  MOVWF  64
....................    frecuencia=1000000.0/tiempo_cal; //esto es porque 1/(2N*micro)=(10^6)/2N 
00B2:  MOVF   64,W
00B3:  MOVWF  68
00B4:  MOVF   63,W
00B5:  MOVWF  67
00B6:  CALL   071
00B7:  CLRF   6A
00B8:  MOVLW  24
00B9:  MOVWF  69
00BA:  MOVLW  74
00BB:  MOVWF  68
00BC:  MOVLW  92
00BD:  MOVWF  67
00BE:  MOVF   7A,W
00BF:  MOVWF  6E
00C0:  MOVF   79,W
00C1:  MOVWF  6D
00C2:  MOVF   78,W
00C3:  MOVWF  6C
00C4:  MOVF   77,W
00C5:  MOVWF  6B
*
018F:  MOVF   7A,W
0190:  MOVWF  6A
0191:  MOVF   79,W
0192:  MOVWF  69
0193:  MOVF   78,W
0194:  MOVWF  68
0195:  MOVF   77,W
0196:  MOVWF  67
0197:  CALL   08E
0198:  MOVF   79,W
0199:  MOVWF  66
019A:  MOVF   78,W
019B:  MOVWF  65
....................    return frecuencia; 
019C:  MOVF   65,W
019D:  MOVWF  78
019E:  MOVF   66,W
019F:  MOVWF  79
.................... } 
01A0:  RETURN
....................  
....................  
....................  
....................  
.................... #IFNDEF S0 
.................... #define S0 PIN_B1 
.................... #define S1 PIN_B2 
.................... #define S2 PIN_B6 
.................... #define S3 PIN_B4 
.................... #define OE PIN_B5 
.................... #ENDIF 
....................  
.................... float nivel=1.53; 
.................... int8 offset_r=167;//167 
.................... int8 offset_g=133;//133 
.................... int8 offset_b=149;//149 
.................... float gan_r=0.654678;//1 
.................... float gan_g=0.812162;//1.22408 
.................... float gan_b=0.739696;//1.08115 
....................  
.................... //Habria que hacer una función "init_tcs" mas general para poder seleccionar otros rangos 
.................... void init_tcs(){ 
....................    init_freq(); 
....................    output_low(S0);// Para seleccionar el rango de 12 KHz 
*
004B:  BSF    03.5
004C:  BCF    06.1
004D:  BCF    03.5
004E:  BCF    06.1
....................    output_high(S1); 
004F:  BSF    03.5
0050:  BCF    06.2
0051:  BCF    03.5
0052:  BSF    06.2
.................... } 
0053:  BCF    0A.3
0054:  GOTO   512 (RETURN)
....................  
.................... void leer_frecuencia_color(int16 *frecuencia_R, int16 *frecuencia_G, int16 *frecuencia_B, int16 *frecuencia_C){ 
....................    float f_R_inter; 
....................    float f_G_inter; 
....................    float f_B_inter; 
....................    float f_C_inter; 
....................     
....................    output_high(OE); 
*
0255:  BSF    03.5
0256:  BCF    06.5
0257:  BCF    03.5
0258:  BSF    06.5
....................    output_low(S2); 
0259:  BSF    03.5
025A:  BCF    06.6
025B:  BCF    03.5
025C:  BCF    06.6
....................    output_low(S3); 
025D:  BSF    03.5
025E:  BCF    06.4
025F:  BCF    03.5
0260:  BCF    06.4
....................     
....................    delay_ms(1); 
0261:  MOVLW  01
0262:  MOVWF  61
0263:  CALL   05D
....................    output_low(OE); 
0264:  BSF    03.5
0265:  BCF    06.5
0266:  BCF    03.5
0267:  BCF    06.5
....................    delay_ms(10); 
0268:  MOVLW  0A
0269:  MOVWF  61
026A:  CALL   05D
....................    f_R_inter=calcula_frecuencia()-offset_r; 
026B:  CALL   0AD
026C:  MOVF   79,W
026D:  MOVWF  62
026E:  MOVF   78,W
026F:  MOVWF  61
0270:  MOVF   2E,W
0271:  SUBWF  78,W
0272:  MOVWF  77
0273:  MOVF   79,W
0274:  MOVWF  7A
0275:  MOVLW  00
0276:  BTFSS  03.0
0277:  MOVLW  01
0278:  SUBWF  7A,F
0279:  MOVF   77,W
027A:  MOVWF  67
027B:  MOVF   7A,W
027C:  MOVWF  68
027D:  CALL   071
027E:  MOVF   7A,W
027F:  MOVWF  54
0280:  MOVF   79,W
0281:  MOVWF  53
0282:  MOVF   78,W
0283:  MOVWF  52
0284:  MOVF   77,W
0285:  MOVWF  51
....................    f_R_inter=f_R_inter*gan_r; 
0286:  MOVF   54,W
0287:  MOVWF  64
0288:  MOVF   53,W
0289:  MOVWF  63
028A:  MOVF   52,W
028B:  MOVWF  62
028C:  MOVF   51,W
028D:  MOVWF  61
028E:  MOVF   34,W
028F:  MOVWF  68
0290:  MOVF   33,W
0291:  MOVWF  67
0292:  MOVF   32,W
0293:  MOVWF  66
0294:  MOVF   31,W
0295:  MOVWF  65
0296:  CALL   1A1
0297:  MOVF   7A,W
0298:  MOVWF  54
0299:  MOVF   79,W
029A:  MOVWF  53
029B:  MOVF   78,W
029C:  MOVWF  52
029D:  MOVF   77,W
029E:  MOVWF  51
....................     
....................    if(f_R_inter<0){ 
029F:  MOVF   54,W
02A0:  MOVWF  64
02A1:  MOVF   53,W
02A2:  MOVWF  63
02A3:  MOVF   52,W
02A4:  MOVWF  62
02A5:  MOVF   51,W
02A6:  MOVWF  61
02A7:  CLRF   68
02A8:  CLRF   67
02A9:  CLRF   66
02AA:  CLRF   65
02AB:  CALL   216
02AC:  BTFSS  03.0
02AD:  GOTO   2B8
....................       *frecuencia_R=0;    
02AE:  MOVF   49,W
02AF:  MOVWF  04
02B0:  BCF    03.7
02B1:  BTFSC  4A.0
02B2:  BSF    03.7
02B3:  INCF   04,F
02B4:  CLRF   00
02B5:  DECF   04,F
02B6:  CLRF   00
....................    } 
....................    else{ 
02B7:  GOTO   2CE
....................       *frecuencia_R=(int16)f_R_inter; 
02B8:  MOVF   4A,W
02B9:  MOVWF  7A
02BA:  MOVF   49,W
02BB:  MOVWF  04
02BC:  BCF    03.7
02BD:  BTFSC  4A.0
02BE:  BSF    03.7
02BF:  MOVF   54,W
02C0:  MOVWF  6A
02C1:  MOVF   53,W
02C2:  MOVWF  69
02C3:  MOVF   52,W
02C4:  MOVWF  68
02C5:  MOVF   51,W
02C6:  MOVWF  67
02C7:  CALL   08E
02C8:  INCF   04,F
02C9:  MOVF   79,W
02CA:  MOVWF  00
02CB:  DECF   04,F
02CC:  MOVF   78,W
02CD:  MOVWF  00
....................    } 
....................     
....................     
....................    //Azul 
....................    output_high(OE); 
02CE:  BSF    03.5
02CF:  BCF    06.5
02D0:  BCF    03.5
02D1:  BSF    06.5
....................    output_low(S2); 
02D2:  BSF    03.5
02D3:  BCF    06.6
02D4:  BCF    03.5
02D5:  BCF    06.6
....................    output_high(S3); 
02D6:  BSF    03.5
02D7:  BCF    06.4
02D8:  BCF    03.5
02D9:  BSF    06.4
....................     
....................    delay_ms(1); 
02DA:  MOVLW  01
02DB:  MOVWF  61
02DC:  CALL   05D
....................    output_low(OE); 
02DD:  BSF    03.5
02DE:  BCF    06.5
02DF:  BCF    03.5
02E0:  BCF    06.5
....................    delay_ms(10); 
02E1:  MOVLW  0A
02E2:  MOVWF  61
02E3:  CALL   05D
....................    f_B_inter=calcula_frecuencia()-offset_b; 
02E4:  CALL   0AD
02E5:  MOVF   79,W
02E6:  MOVWF  62
02E7:  MOVF   78,W
02E8:  MOVWF  61
02E9:  MOVF   30,W
02EA:  SUBWF  78,W
02EB:  MOVWF  77
02EC:  MOVF   79,W
02ED:  MOVWF  7A
02EE:  MOVLW  00
02EF:  BTFSS  03.0
02F0:  MOVLW  01
02F1:  SUBWF  7A,F
02F2:  MOVF   77,W
02F3:  MOVWF  67
02F4:  MOVF   7A,W
02F5:  MOVWF  68
02F6:  CALL   071
02F7:  MOVF   7A,W
02F8:  MOVWF  5C
02F9:  MOVF   79,W
02FA:  MOVWF  5B
02FB:  MOVF   78,W
02FC:  MOVWF  5A
02FD:  MOVF   77,W
02FE:  MOVWF  59
....................    f_B_inter=f_B_inter*gan_b; 
02FF:  MOVF   5C,W
0300:  MOVWF  64
0301:  MOVF   5B,W
0302:  MOVWF  63
0303:  MOVF   5A,W
0304:  MOVWF  62
0305:  MOVF   59,W
0306:  MOVWF  61
0307:  MOVF   3C,W
0308:  MOVWF  68
0309:  MOVF   3B,W
030A:  MOVWF  67
030B:  MOVF   3A,W
030C:  MOVWF  66
030D:  MOVF   39,W
030E:  MOVWF  65
030F:  CALL   1A1
0310:  MOVF   7A,W
0311:  MOVWF  5C
0312:  MOVF   79,W
0313:  MOVWF  5B
0314:  MOVF   78,W
0315:  MOVWF  5A
0316:  MOVF   77,W
0317:  MOVWF  59
....................    if(f_B_inter<0){ 
0318:  MOVF   5C,W
0319:  MOVWF  64
031A:  MOVF   5B,W
031B:  MOVWF  63
031C:  MOVF   5A,W
031D:  MOVWF  62
031E:  MOVF   59,W
031F:  MOVWF  61
0320:  CLRF   68
0321:  CLRF   67
0322:  CLRF   66
0323:  CLRF   65
0324:  CALL   216
0325:  BTFSS  03.0
0326:  GOTO   331
....................       *frecuencia_B=0;    
0327:  MOVF   4D,W
0328:  MOVWF  04
0329:  BCF    03.7
032A:  BTFSC  4E.0
032B:  BSF    03.7
032C:  INCF   04,F
032D:  CLRF   00
032E:  DECF   04,F
032F:  CLRF   00
....................    } 
....................    else{ 
0330:  GOTO   347
....................       *frecuencia_B=(int16)f_B_inter; 
0331:  MOVF   4E,W
0332:  MOVWF  7A
0333:  MOVF   4D,W
0334:  MOVWF  04
0335:  BCF    03.7
0336:  BTFSC  4E.0
0337:  BSF    03.7
0338:  MOVF   5C,W
0339:  MOVWF  6A
033A:  MOVF   5B,W
033B:  MOVWF  69
033C:  MOVF   5A,W
033D:  MOVWF  68
033E:  MOVF   59,W
033F:  MOVWF  67
0340:  CALL   08E
0341:  INCF   04,F
0342:  MOVF   79,W
0343:  MOVWF  00
0344:  DECF   04,F
0345:  MOVF   78,W
0346:  MOVWF  00
....................    } 
....................     
....................    //Verde 
....................    output_high(OE); 
0347:  BSF    03.5
0348:  BCF    06.5
0349:  BCF    03.5
034A:  BSF    06.5
....................    output_high(S2); 
034B:  BSF    03.5
034C:  BCF    06.6
034D:  BCF    03.5
034E:  BSF    06.6
....................    output_high(S3); 
034F:  BSF    03.5
0350:  BCF    06.4
0351:  BCF    03.5
0352:  BSF    06.4
....................     
....................    delay_ms(1); 
0353:  MOVLW  01
0354:  MOVWF  61
0355:  CALL   05D
....................    output_low(OE); 
0356:  BSF    03.5
0357:  BCF    06.5
0358:  BCF    03.5
0359:  BCF    06.5
....................    delay_ms(10); 
035A:  MOVLW  0A
035B:  MOVWF  61
035C:  CALL   05D
....................    f_G_inter=calcula_frecuencia()-offset_g; 
035D:  CALL   0AD
035E:  MOVF   79,W
035F:  MOVWF  62
0360:  MOVF   78,W
0361:  MOVWF  61
0362:  MOVF   2F,W
0363:  SUBWF  78,W
0364:  MOVWF  77
0365:  MOVF   79,W
0366:  MOVWF  7A
0367:  MOVLW  00
0368:  BTFSS  03.0
0369:  MOVLW  01
036A:  SUBWF  7A,F
036B:  MOVF   77,W
036C:  MOVWF  67
036D:  MOVF   7A,W
036E:  MOVWF  68
036F:  CALL   071
0370:  MOVF   7A,W
0371:  MOVWF  58
0372:  MOVF   79,W
0373:  MOVWF  57
0374:  MOVF   78,W
0375:  MOVWF  56
0376:  MOVF   77,W
0377:  MOVWF  55
....................    f_G_inter=f_G_inter*gan_g; 
0378:  MOVF   58,W
0379:  MOVWF  64
037A:  MOVF   57,W
037B:  MOVWF  63
037C:  MOVF   56,W
037D:  MOVWF  62
037E:  MOVF   55,W
037F:  MOVWF  61
0380:  MOVF   38,W
0381:  MOVWF  68
0382:  MOVF   37,W
0383:  MOVWF  67
0384:  MOVF   36,W
0385:  MOVWF  66
0386:  MOVF   35,W
0387:  MOVWF  65
0388:  CALL   1A1
0389:  MOVF   7A,W
038A:  MOVWF  58
038B:  MOVF   79,W
038C:  MOVWF  57
038D:  MOVF   78,W
038E:  MOVWF  56
038F:  MOVF   77,W
0390:  MOVWF  55
....................    if(f_G_inter<0){ 
0391:  MOVF   58,W
0392:  MOVWF  64
0393:  MOVF   57,W
0394:  MOVWF  63
0395:  MOVF   56,W
0396:  MOVWF  62
0397:  MOVF   55,W
0398:  MOVWF  61
0399:  CLRF   68
039A:  CLRF   67
039B:  CLRF   66
039C:  CLRF   65
039D:  CALL   216
039E:  BTFSS  03.0
039F:  GOTO   3AA
....................       *frecuencia_G=0;    
03A0:  MOVF   4B,W
03A1:  MOVWF  04
03A2:  BCF    03.7
03A3:  BTFSC  4C.0
03A4:  BSF    03.7
03A5:  INCF   04,F
03A6:  CLRF   00
03A7:  DECF   04,F
03A8:  CLRF   00
....................    } 
....................    else{ 
03A9:  GOTO   3C0
....................       *frecuencia_G=(int16)f_G_inter; 
03AA:  MOVF   4C,W
03AB:  MOVWF  7A
03AC:  MOVF   4B,W
03AD:  MOVWF  04
03AE:  BCF    03.7
03AF:  BTFSC  4C.0
03B0:  BSF    03.7
03B1:  MOVF   58,W
03B2:  MOVWF  6A
03B3:  MOVF   57,W
03B4:  MOVWF  69
03B5:  MOVF   56,W
03B6:  MOVWF  68
03B7:  MOVF   55,W
03B8:  MOVWF  67
03B9:  CALL   08E
03BA:  INCF   04,F
03BB:  MOVF   79,W
03BC:  MOVWF  00
03BD:  DECF   04,F
03BE:  MOVF   78,W
03BF:  MOVWF  00
....................    } 
....................     
....................    //Claro 
....................    output_high(OE); 
03C0:  BSF    03.5
03C1:  BCF    06.5
03C2:  BCF    03.5
03C3:  BSF    06.5
....................    output_high(S2); 
03C4:  BSF    03.5
03C5:  BCF    06.6
03C6:  BCF    03.5
03C7:  BSF    06.6
....................    output_low(S3); 
03C8:  BSF    03.5
03C9:  BCF    06.4
03CA:  BCF    03.5
03CB:  BCF    06.4
....................     
....................    delay_ms(1); 
03CC:  MOVLW  01
03CD:  MOVWF  61
03CE:  CALL   05D
....................    output_low(OE); 
03CF:  BSF    03.5
03D0:  BCF    06.5
03D1:  BCF    03.5
03D2:  BCF    06.5
....................    delay_ms(10); 
03D3:  MOVLW  0A
03D4:  MOVWF  61
03D5:  CALL   05D
....................    *frecuencia_C=calcula_frecuencia(); 
03D6:  MOVF   50,W
03D7:  MOVWF  7A
03D8:  MOVF   4F,W
03D9:  MOVWF  61
03DA:  MOVF   50,W
03DB:  MOVWF  62
03DC:  CALL   0AD
03DD:  MOVF   61,W
03DE:  MOVWF  04
03DF:  BCF    03.7
03E0:  BTFSC  62.0
03E1:  BSF    03.7
03E2:  INCF   04,F
03E3:  MOVF   79,W
03E4:  MOVWF  00
03E5:  DECF   04,F
03E6:  MOVF   78,W
03E7:  MOVWF  00
....................     
....................  
.................... } 
03E8:  BCF    0A.3
03E9:  GOTO   520 (RETURN)
....................  
.................... int8 busca_maximo(int16 vector[], int8 elementos){ 
....................    int8 i; 
....................    int8 indice; 
....................    int16 mayor; 
....................    mayor=vector[0]; 
03EA:  MOVF   67,W
03EB:  MOVWF  04
03EC:  BCF    03.7
03ED:  BTFSC  68.0
03EE:  BSF    03.7
03EF:  INCF   04,F
03F0:  MOVF   00,W
03F1:  MOVWF  7A
03F2:  DECF   04,F
03F3:  MOVF   00,W
03F4:  MOVWF  6C
03F5:  MOVF   7A,W
03F6:  MOVWF  6D
....................    indice=0; 
03F7:  CLRF   6B
....................    for(i=0;i<elementos;i++){ 
03F8:  CLRF   6A
03F9:  MOVF   69,W
03FA:  SUBWF  6A,W
03FB:  BTFSC  03.0
03FC:  GOTO   427
....................       if(vector[i]>mayor){ 
03FD:  BCF    03.0
03FE:  RLF    6A,W
03FF:  ADDWF  67,W
0400:  MOVWF  04
0401:  BCF    03.7
0402:  BTFSC  68.0
0403:  BSF    03.7
0404:  INCF   04,F
0405:  MOVF   00,W
0406:  MOVWF  6F
0407:  DECF   04,F
0408:  MOVF   00,W
0409:  MOVWF  6E
040A:  MOVF   6D,W
040B:  SUBWF  6F,W
040C:  BTFSS  03.0
040D:  GOTO   425
040E:  BTFSS  03.2
040F:  GOTO   414
0410:  MOVF   6E,W
0411:  SUBWF  6C,W
0412:  BTFSC  03.0
0413:  GOTO   425
....................          mayor=vector[i]; 
0414:  BCF    03.0
0415:  RLF    6A,W
0416:  ADDWF  67,W
0417:  MOVWF  04
0418:  BCF    03.7
0419:  BTFSC  68.0
041A:  BSF    03.7
041B:  INCF   04,F
041C:  MOVF   00,W
041D:  MOVWF  7A
041E:  DECF   04,F
041F:  MOVF   00,W
0420:  MOVWF  6C
0421:  MOVF   7A,W
0422:  MOVWF  6D
....................          indice=i; 
0423:  MOVF   6A,W
0424:  MOVWF  6B
....................       } 
....................    } 
0425:  INCF   6A,F
0426:  GOTO   3F9
....................    return indice; 
0427:  MOVF   6B,W
0428:  MOVWF  78
.................... } 
0429:  RETURN
....................  
.................... int8 busca_maximo2(int16 vector[], int8 elementos){ 
....................    int8 i; 
....................    int8 indice; 
....................    int8 max; 
....................    int16 mayor; 
....................    max=busca_maximo(vector,elementos); 
*
046F:  MOVF   60,W
0470:  MOVWF  68
0471:  MOVF   5F,W
0472:  MOVWF  67
0473:  MOVF   61,W
0474:  MOVWF  69
0475:  CALL   3EA
0476:  MOVF   78,W
0477:  MOVWF  64
....................    mayor=0; 
0478:  CLRF   66
0479:  CLRF   65
....................    indice=0; 
047A:  CLRF   63
....................    for(i=0;i<elementos;i++){ 
047B:  CLRF   62
047C:  MOVF   61,W
047D:  SUBWF  62,W
047E:  BTFSC  03.0
047F:  GOTO   4AE
....................       if(i!=max){ 
0480:  MOVF   64,W
0481:  SUBWF  62,W
0482:  BTFSC  03.2
0483:  GOTO   4AC
....................          if(vector[i]>mayor){ 
0484:  BCF    03.0
0485:  RLF    62,W
0486:  ADDWF  5F,W
0487:  MOVWF  04
0488:  BCF    03.7
0489:  BTFSC  60.0
048A:  BSF    03.7
048B:  INCF   04,F
048C:  MOVF   00,W
048D:  MOVWF  68
048E:  DECF   04,F
048F:  MOVF   00,W
0490:  MOVWF  67
0491:  MOVF   66,W
0492:  SUBWF  68,W
0493:  BTFSS  03.0
0494:  GOTO   4AC
0495:  BTFSS  03.2
0496:  GOTO   49B
0497:  MOVF   67,W
0498:  SUBWF  65,W
0499:  BTFSC  03.0
049A:  GOTO   4AC
....................             mayor=vector[i]; 
049B:  BCF    03.0
049C:  RLF    62,W
049D:  ADDWF  5F,W
049E:  MOVWF  04
049F:  BCF    03.7
04A0:  BTFSC  60.0
04A1:  BSF    03.7
04A2:  INCF   04,F
04A3:  MOVF   00,W
04A4:  MOVWF  7A
04A5:  DECF   04,F
04A6:  MOVF   00,W
04A7:  MOVWF  65
04A8:  MOVF   7A,W
04A9:  MOVWF  66
....................             indice=i; 
04AA:  MOVF   62,W
04AB:  MOVWF  63
....................          } 
....................       } 
....................    } 
04AC:  INCF   62,F
04AD:  GOTO   47C
....................    return indice; 
04AE:  MOVF   63,W
04AF:  MOVWF  78
.................... } 
....................  
.................... //Otro metodo 
.................... int8 detectar_color(int16 fred, int16 fblue,int16 fgreen, int16 fclear){ 
*
0433:  MOVLW  08
0434:  MOVWF  5C
....................    int16 rgb[3]={0,0,0};    
*
042A:  CLRF   51
042B:  CLRF   52
042C:  CLRF   53
042D:  CLRF   54
042E:  CLRF   55
042F:  CLRF   56
....................    int8 rgb2[3]={0,0,0}; 
0430:  CLRF   57
0431:  CLRF   58
0432:  CLRF   59
....................    int8 max1,max2; 
....................    int8 color=8; 
....................    int16 direccion; 
....................     
....................    rgb[0]=fred; 
*
0435:  MOVF   4A,W
0436:  MOVWF  52
0437:  MOVF   49,W
0438:  MOVWF  51
....................    rgb[1]=fgreen; 
0439:  MOVF   4E,W
043A:  MOVWF  54
043B:  MOVF   4D,W
043C:  MOVWF  53
....................    rgb[2]=fblue; 
043D:  MOVF   4C,W
043E:  MOVWF  56
043F:  MOVF   4B,W
0440:  MOVWF  55
....................    max1=busca_maximo(rgb,3); 
0441:  CLRF   68
0442:  MOVLW  51
0443:  MOVWF  67
0444:  MOVLW  03
0445:  MOVWF  69
0446:  CALL   3EA
0447:  MOVF   78,W
0448:  MOVWF  5A
....................  
....................    if(fclear<6100){ 
0449:  MOVF   50,W
044A:  SUBLW  17
044B:  BTFSS  03.0
044C:  GOTO   46A
044D:  BTFSS  03.2
044E:  GOTO   453
044F:  MOVF   4F,W
0450:  SUBLW  D3
0451:  BTFSS  03.0
0452:  GOTO   46A
....................        
....................       switch(max1){ 
0453:  MOVF   5A,W
0454:  BTFSC  03.2
0455:  GOTO   45D
0456:  XORLW  01
0457:  BTFSC  03.2
0458:  GOTO   460
0459:  XORLW  03
045A:  BTFSC  03.2
045B:  GOTO   463
045C:  GOTO   466
....................          case 0: 
....................             color=4; 
045D:  MOVLW  04
045E:  MOVWF  5C
....................             break; 
045F:  GOTO   469
....................          case 1: 
....................             color=2; 
0460:  MOVLW  02
0461:  MOVWF  5C
....................             break; 
0462:  GOTO   469
....................          case 2: 
....................             color=1; 
0463:  MOVLW  01
0464:  MOVWF  5C
....................             break; 
0465:  GOTO   469
....................          default: 
....................             color=8; 
0466:  MOVLW  08
0467:  MOVWF  5C
....................             break; 
0468:  GOTO   469
....................       } 
....................    } 
....................    else{ 
0469:  GOTO   4C8
....................       max2=busca_maximo2(rgb,3); 
046A:  CLRF   60
046B:  MOVLW  51
046C:  MOVWF  5F
046D:  MOVLW  03
046E:  MOVWF  61
*
04B0:  MOVF   78,W
04B1:  MOVWF  5B
....................       rgb2[max1]=1; 
04B2:  MOVLW  57
04B3:  ADDWF  5A,W
04B4:  MOVWF  04
04B5:  BCF    03.7
04B6:  MOVLW  01
04B7:  MOVWF  00
....................       rgb2[max2]=1; 
04B8:  MOVLW  57
04B9:  ADDWF  5B,W
04BA:  MOVWF  04
04BB:  BCF    03.7
04BC:  MOVLW  01
04BD:  MOVWF  00
....................       color=(rgb2[0]<<2)+(rgb2[1]<<1)+rgb2[2]; 
04BE:  RLF    57,W
04BF:  MOVWF  5F
04C0:  RLF    5F,F
04C1:  MOVLW  FC
04C2:  ANDWF  5F,F
04C3:  BCF    03.0
04C4:  RLF    58,W
04C5:  ADDWF  5F,W
04C6:  ADDWF  59,W
04C7:  MOVWF  5C
....................    } 
....................    return color; 
04C8:  MOVF   5C,W
04C9:  MOVWF  78
....................  
.................... } 
04CA:  BCF    0A.3
04CB:  GOTO   531 (RETURN)
....................  
.................... //Buscar el mas chico y dividirlo entre el más chico. Los que esten por encima de un nivel son "1" y los que sean menores son "0" 
.................... //! 
.................... //!int8 detectar_color(int16 fred, int16 fblue,int16 fgreen){ 
.................... //!   int8 color; 
.................... //!   int16 mini=1; 
.................... //!   float nred; 
.................... //!   float nblue; 
.................... //!   float ngreen; 
.................... //!   int8 bitred; 
.................... //!   int8 bitblue; 
.................... //!   int8 bitgreen; 
.................... //!    
.................... //!   if(fred<fblue){ 
.................... //!      if(fred<fgreen){ 
.................... //!         mini=fred; 
.................... //!      } 
.................... //!      else{ 
.................... //!         mini=fgreen; 
.................... //!      } 
.................... //!   } 
.................... //!   else{ 
.................... //!      if(fblue<fgreen){ 
.................... //!         mini=fblue; 
.................... //!      } 
.................... //!      else{ 
.................... //!         mini=fgreen; 
.................... //!      } 
.................... //!   } 
.................... //!   nred=(float)fred/(float)mini; 
.................... //!   nblue=(float)fblue/(float)mini; 
.................... //!   ngreen=(float)fgreen/(float)mini; 
.................... //!    
.................... //!   if(nred>nivel){ 
.................... //!      bitred=1; 
.................... //!   } 
.................... //!   else{ 
.................... //!      bitred=0; 
.................... //!   } 
.................... //!   if(nblue>nivel){ 
.................... //!      bitblue=1; 
.................... //!   } 
.................... //!   else{ 
.................... //!      bitblue=0; 
.................... //!   } 
.................... //!   if(ngreen>nivel){ 
.................... //!      bitgreen=1; 
.................... //!   } 
.................... //!   else{ 
.................... //!      bitgreen=0; 
.................... //!   } 
.................... //!   color=(bitred<<2)+(bitgreen<<1)+bitblue; 
.................... //!    
.................... //!   if(color==0){ 
.................... //!      if(fred>1000){ 
.................... //!         color=7; 
.................... //!      } 
.................... //!   } 
.................... //!   else if((fred<1000)&&(fblue<1000)&&(fgreen<1000)){ 
.................... //!      color=8; 
.................... //!   } 
.................... //!    
.................... //!   return color; 
.................... //!} 
.................... //! 
.................... //! 
....................  
....................  
.................... //COLOR2MUSIC 
.................... //Autor: Nicolás Guerrero García (Nitehack) 
.................... //Resumen: Transforma un sonido físico a una nota músical, pudiendo así generar musica con diferentes objetos de diferentes colores. 
....................  
....................  
....................  
.................... //ANOTACIONES: 
.................... //Hay que poner el máximo de frecuencia para medir tiempos muy cortos y el minimo de 
.................... // rango para que el error para medir la frecuencia con el metodo de medir 
.................... // el periodo sea minimo ya que falla solo cuando son muy altas las frecuencias 
.................... //Preescaler de 4 con minimo de 7 Hz 
.................... // Si se desborda el timer poner una interrupcion y poner de frecuencia 0Hz 
.................... //Poner reloj de 20 MHz externo 
.................... //Al final el reloj va a ser el de 8 MHz interno 
.................... // Se puede poner un umbral para considerar colo o no 
....................  
.................... //Informacion 
.................... //----------- 
.................... // Con 12 KHz 
.................... //Maxima frecuencia para R: 13157 Hz  
.................... //Maxima frecuencia para B: 13157 Hz (En hexadecimal 3365 Hz) 
.................... // Maxima frecuencia para G:  11111 Hz (En hexadecimal 2B67) 
.................... //MinimaR:169 Hz (A9) 
.................... // Minima G: 135 Hz (87) 
.................... //Minima B: 150 Hz (96) 
....................  
.................... //Que hay que hacer: 
.................... //------------------ 
.................... //Corregir error de 0 y de ganancia para los 3 filtros 
.................... //Posibles problemas!!:  
.................... //---------------------- 
.................... //Que el contador del timer se desborde por que pase demasiado tiempo , es decir cuando sean bajas frecuencias 
.................... // 
.................... //Sonido 
.................... //------ 
.................... //Espectro de frecuencias de sonido: 30 Hz a 15 KHz 
.................... //PeridoPWM= (periodo_TMR2+1)·4·Tosc· prescaler_TMR2 
.................... //Hay que poner el preescaler el mas alto (16) ya que buscamos el myor rango entre 30 y 15 KHz, y para conseguir 
.................... //He usado desde 523 Hz hasta 980 Hz, y se puede usar un total de 12 notas 
....................  
....................  
.................... //Para corregir el offset del sensor 
....................  
.................... //Capturar flanco-> contar tiempo-> Capturar flanco-> Parar tiempo-> Leer tiempo-> Cambiar a frecuencia 
....................  
....................  
.................... void main() 
.................... { 
04CC:  CLRF   04
04CD:  BCF    03.7
04CE:  MOVLW  1F
04CF:  ANDWF  03,F
04D0:  MOVLW  72
04D1:  BSF    03.5
04D2:  MOVWF  0F
04D3:  MOVF   0F,W
04D4:  BCF    03.5
04D5:  CLRF   29
04D6:  CLRF   28
04D7:  MOVLW  0A
04D8:  MOVWF  2D
04D9:  MOVLW  D7
04DA:  MOVWF  2C
04DB:  MOVLW  43
04DC:  MOVWF  2B
04DD:  MOVLW  7F
04DE:  MOVWF  2A
04DF:  MOVLW  A7
04E0:  MOVWF  2E
04E1:  MOVLW  85
04E2:  MOVWF  2F
04E3:  MOVLW  95
04E4:  MOVWF  30
04E5:  MOVLW  FA
04E6:  MOVWF  34
04E7:  MOVLW  98
04E8:  MOVWF  33
04E9:  MOVLW  27
04EA:  MOVWF  32
04EB:  MOVLW  7E
04EC:  MOVWF  31
04ED:  MOVLW  D9
04EE:  MOVWF  38
04EF:  MOVLW  E9
04F0:  MOVWF  37
04F1:  MOVLW  4F
04F2:  MOVWF  36
04F3:  MOVLW  7E
04F4:  MOVWF  35
04F5:  MOVLW  B8
04F6:  MOVWF  3C
04F7:  MOVLW  5C
04F8:  MOVWF  3B
04F9:  MOVLW  3D
04FA:  MOVWF  3A
04FB:  MOVLW  7E
04FC:  MOVWF  39
04FD:  BSF    03.5
04FE:  BCF    1F.4
04FF:  BCF    1F.5
0500:  MOVF   1B,W
0501:  ANDLW  80
0502:  MOVWF  1B
0503:  MOVLW  07
0504:  MOVWF  1C
0505:  BCF    03.5
0506:  CLRF   3E
0507:  CLRF   3D
0508:  CLRF   40
0509:  CLRF   3F
050A:  CLRF   42
050B:  CLRF   41
050C:  CLRF   44
050D:  CLRF   43
050E:  CLRF   45
050F:  CLRF   46
0510:  CLRF   47
....................    int16 frecuencia_R=0; 
....................    int16 frecuencia_G=0; 
....................    int16 frecuencia_B=0; 
....................    int16 frecuencia_C=0; 
....................     
....................    int8 dato=0; 
....................    int8 maximo=0; 
....................    int8 direccion=0; 
....................    int8 color; 
....................     
....................    init_tcs(); 
0511:  GOTO   042
....................    init_sound(); 
0512:  GOTO   055
....................     
....................    while(true){ 
....................       leer_frecuencia_color(&frecuencia_R,&frecuencia_G, &frecuencia_B, &frecuencia_C); 
0513:  CLRF   4A
0514:  MOVLW  3D
0515:  MOVWF  49
0516:  CLRF   4C
0517:  MOVLW  3F
0518:  MOVWF  4B
0519:  CLRF   4E
051A:  MOVLW  41
051B:  MOVWF  4D
051C:  CLRF   50
051D:  MOVLW  43
051E:  MOVWF  4F
051F:  GOTO   255
....................       //Atencion!! Para hacer debug hay que tener en cuenta que antes la funcion esa le resta el offset que tiene luego la frecuencia es distinta  
.................... //!      dato=(int8)(frecuencia_R>>8); 
.................... //!      write_eeprom(direccion, dato); 
.................... //!      dato=(int8)(frecuencia_R); 
.................... //!      write_eeprom(direccion+1, dato); 
.................... //!       
.................... //!      dato=(int8)(frecuencia_G>>8); 
.................... //!      write_eeprom(direccion+2, dato); 
.................... //!      dato=(int8)(frecuencia_G); 
.................... //!      write_eeprom(direccion+3, dato); 
.................... //!       
.................... //!      dato=(int8)(frecuencia_B>>8); 
.................... //!      write_eeprom(direccion+4, dato); 
.................... //!      dato=(int8)(frecuencia_B); 
.................... //!      write_eeprom(direccion+5, dato); 
.................... //!       
.................... //!      dato=(int8)(frecuencia_C>>8); 
.................... //!      write_eeprom(direccion+6, dato); 
.................... //!      dato=(int8)(frecuencia_C); 
.................... //!      write_eeprom(direccion+7, dato); 
.................... //!       
.................... //!      direccion=direccion+9; 
.................... //!      if (direccion>=240){ 
.................... //!         direccion=0; 
.................... //!      } 
....................        
....................       color=detectar_color(frecuencia_R,frecuencia_B,frecuencia_G,frecuencia_C); 
0520:  MOVF   3E,W
0521:  MOVWF  4A
0522:  MOVF   3D,W
0523:  MOVWF  49
0524:  MOVF   42,W
0525:  MOVWF  4C
0526:  MOVF   41,W
0527:  MOVWF  4B
0528:  MOVF   40,W
0529:  MOVWF  4E
052A:  MOVF   3F,W
052B:  MOVWF  4D
052C:  MOVF   44,W
052D:  MOVWF  50
052E:  MOVF   43,W
052F:  MOVWF  4F
0530:  GOTO   42A
0531:  MOVF   78,W
0532:  MOVWF  48
....................       write_eeprom(direccion, color); 
0533:  MOVF   47,W
0534:  BSF    03.6
0535:  MOVWF  0D
0536:  BCF    03.6
0537:  MOVF   48,W
0538:  BSF    03.6
0539:  MOVWF  0C
053A:  BSF    03.5
053B:  BCF    0C.7
053C:  BSF    0C.2
053D:  BCF    03.5
053E:  BCF    03.6
053F:  MOVF   0B,W
0540:  MOVWF  77
0541:  BCF    0B.7
0542:  BSF    03.5
0543:  BSF    03.6
0544:  MOVLW  55
0545:  MOVWF  0D
0546:  MOVLW  AA
0547:  MOVWF  0D
0548:  BSF    0C.1
0549:  BTFSC  0C.1
054A:  GOTO   549
054B:  BCF    0C.2
054C:  MOVF   77,W
054D:  BCF    03.5
054E:  BCF    03.6
054F:  IORWF  0B,F
....................       direccion++; 
0550:  INCF   47,F
....................       if(direccion>240){ 
0551:  MOVF   47,W
0552:  SUBLW  F0
0553:  BTFSC  03.0
0554:  GOTO   556
....................          direccion=0; 
0555:  CLRF   47
....................       } 
....................        
.................... //!      genera_sonido(DOn); 
.................... //!      delay_ms(2000); 
.................... //!      genera_sonido(REn); 
.................... //!      delay_ms(2000); 
.................... //!      genera_sonido(MIn); 
.................... //!      delay_ms(2000); 
.................... //!      genera_sonido(FAn); 
.................... //!      delay_ms(2000); 
.................... //!      genera_sonido(SOLn); 
.................... //!      delay_ms(2000); 
.................... //!      genera_sonido(LAn); 
.................... //!      delay_ms(2000); 
.................... //!      genera_sonido(SIn); 
.................... //!      delay_ms(2000); 
.................... //!      write_eeprom(direccion, color); 
.................... //!      direccion++; 
.................... //!      if(direccion>254){ 
.................... //!         direccion=0; 
.................... //!      } 
.................... //!      switch(color){ 
.................... //!         case 0: 
.................... //!            genera_sonido(NONE); 
.................... //!            //output_high(PIN_A0); 
.................... //!            //delay_ms(2000); 
.................... //!            break; 
.................... //!         case 1: 
.................... //!            genera_sonido(REn); 
.................... //!            output_high(PIN_A1); 
.................... //!            delay_ms(ntime); 
.................... //!            break; 
.................... //!         case 2: 
.................... //!            genera_sonido(MIn); 
.................... //!            output_high(PIN_A2); 
.................... //!            delay_ms(ntime); 
.................... //!            break; 
.................... //!         case 3: 
.................... //!            genera_sonido(FAn); 
.................... //!            delay_ms(ntime); 
.................... //!            break; 
.................... //!         case 4: 
.................... //!            genera_sonido(SOLn); 
.................... //!            delay_ms(ntime); 
.................... //!            break; 
.................... //!         case 5: 
.................... //!            genera_sonido(LAn); 
.................... //!            delay_ms(ntime); 
.................... //!            break; 
.................... //!         case 6: 
.................... //!            genera_sonido(SIn); 
.................... //!            delay_ms(ntime); 
.................... //!            break; 
.................... //!         case 7: 
.................... //!            genera_sonido(NONE); 
.................... //!            break; 
.................... //!         default: 
.................... //!            genera_sonido(NONE); 
.................... //!             
.................... //!            break; 
.................... //!      } 
....................  
....................    } 
0556:  GOTO   513
....................     
.................... } 
0557:  SLEEP

Configuration Fuses:
   Word  1: 2F38   NOWDT NOPUT MCLR NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG CCPB3 NOPROTECT INTRC_IO
   Word  2: 3FFF   FCMEN IESO
