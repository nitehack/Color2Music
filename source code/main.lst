CCS PCM C Compiler, Version 4.104, 5967               11-dic.-14 00:09

               Filename: C:\Users\Ali\Documents\GitHub\Color2Music\source code\main.lst

               ROM used: 1030 words (25%)
                         Largest free fragment is 2048
               RAM used: 28 (8%) at main() level
                         53 (14%) worst case
               Stack:    3 worst case (2 in main + 1 for interrupts)

*
0000:  MOVLW  02
0001:  MOVWF  0A
0002:  GOTO   263
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   7F,W
0009:  MOVWF  20
000A:  MOVF   0A,W
000B:  MOVWF  27
000C:  CLRF   0A
000D:  SWAPF  20,F
000E:  MOVF   04,W
000F:  MOVWF  22
0010:  MOVF   77,W
0011:  MOVWF  23
0012:  MOVF   78,W
0013:  MOVWF  24
0014:  MOVF   79,W
0015:  MOVWF  25
0016:  MOVF   7A,W
0017:  MOVWF  26
0018:  BCF    03.7
0019:  BCF    03.5
001A:  BTFSS  0B.4
001B:  GOTO   01E
001C:  BTFSC  0B.1
001D:  GOTO   02F
001E:  MOVF   22,W
001F:  MOVWF  04
0020:  MOVF   23,W
0021:  MOVWF  77
0022:  MOVF   24,W
0023:  MOVWF  78
0024:  MOVF   25,W
0025:  MOVWF  79
0026:  MOVF   26,W
0027:  MOVWF  7A
0028:  MOVF   27,W
0029:  MOVWF  0A
002A:  SWAPF  21,W
002B:  MOVWF  03
002C:  SWAPF  7F,F
002D:  SWAPF  7F,W
002E:  RETFIE
002F:  BCF    0A.3
0030:  GOTO   031
.................... #include "main.h" 
.................... #include <16F88.h> 
.................... //////// Standard Header file for the PIC16F88 device //////////////// 
.................... #device PIC16F88 
.................... #list 
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES INTRC_IO                 //Internal RC Osc, no CLKOUT 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES MCLR                     //Master Clear pin enabled 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES RESERVED                 //Used to set the reserved FUSE bits 
.................... #FUSES CCPB3                    // Ponemos este fuse para que el PWM salga por la patilla 9 ya que  por defecto está en la 6 y esa ya se usa 
....................  
.................... #use delay(clock=8000000) 
*
005D:  MOVLW  3C
005E:  MOVWF  04
005F:  BCF    03.7
0060:  MOVF   00,W
0061:  BTFSC  03.2
0062:  GOTO   070
0063:  MOVLW  02
0064:  MOVWF  78
0065:  CLRF   77
0066:  DECFSZ 77,F
0067:  GOTO   066
0068:  DECFSZ 78,F
0069:  GOTO   065
006A:  MOVLW  97
006B:  MOVWF  77
006C:  DECFSZ 77,F
006D:  GOTO   06C
006E:  DECFSZ 00,F
006F:  GOTO   063
0070:  RETURN
....................  
....................  
.................... #include "sound.c" 
.................... //Con esta libreria se pueden generar sonidos 
.................... //La función genera sonido esta ya calculada para un reloj de 8 MHz para el rango  
.................... // de frecuencias que nos interesa para esta aplicación. 
.................... //Habria que hacer una función más general. 
....................  
.................... #define SIn 126 
.................... #define LABn 133 
.................... #define LAn 141 
.................... #define SOLBn 150 
.................... #define SOLn 159 
.................... #define FABn 168 
.................... #define FAn 178 
.................... #define MIn 189 
.................... #define REBn 200 
.................... #define REn 212 
.................... #define DOBn 225 
.................... #define DOn 238 
....................  
.................... void init_sound(){ 
....................    setup_ccp1(CCP_PWM); //Indicamos que queremos usar el PWM 
*
0055:  BSF    03.5
0056:  BCF    06.3
0057:  BCF    03.5
0058:  BCF    06.3
0059:  MOVLW  0C
005A:  MOVWF  17
.................... } 
005B:  BCF    0A.3
005C:  GOTO   287 (RETURN)
....................  
.................... void genera_sonido(int8 sonido){ 
....................    int16 value; 
....................    value=(4*((int16)sonido+1))/2; 
*
0232:  CLRF   3A
0233:  MOVLW  01
0234:  ADDWF  36,W
0235:  MOVWF  78
0236:  MOVF   3A,W
0237:  MOVWF  7A
0238:  BTFSC  03.0
0239:  INCF   7A,F
023A:  RLF    78,W
023B:  MOVWF  39
023C:  RLF    7A,W
023D:  MOVWF  3A
023E:  RLF    39,F
023F:  RLF    3A,F
0240:  MOVLW  FC
0241:  ANDWF  39,F
0242:  BCF    03.0
0243:  RRF    3A,W
0244:  MOVWF  38
0245:  RRF    39,W
0246:  MOVWF  37
....................    setup_timer_2(T2_DIV_BY_16, sonido ,4);  
0247:  MOVLW  18
0248:  MOVWF  78
0249:  IORLW  06
024A:  MOVWF  12
024B:  MOVF   36,W
024C:  BSF    03.5
024D:  MOVWF  12
....................    set_pwm1_duty(value); //se establece el ciclo de trabajo 
024E:  BCF    03.5
024F:  MOVF   38,W
0250:  MOVWF  79
0251:  MOVF   37,W
0252:  MOVWF  78
0253:  RRF    79,F
0254:  RRF    78,F
0255:  RRF    79,F
0256:  RRF    78,F
0257:  RRF    79,F
0258:  MOVF   78,W
0259:  MOVWF  15
025A:  RRF    79,F
025B:  RRF    79,W
025C:  ANDLW  30
025D:  MOVWF  77
025E:  MOVF   17,W
025F:  ANDLW  CF
0260:  IORWF  77,W
0261:  MOVWF  17
.................... } 
0262:  RETURN
....................  
.................... #include "color.c" 
.................... /* 
.................... Los pines que se indican en los "defines" son del sensor TCS3200 yl-64 
.................... */ 
.................... #include "frequency.c" 
.................... int16 tiempo=0; 
.................... //Esta librería mide la frecuencia de una señal que entr por RB0 
.................... #INT_EXT 
.................... void llega_pulso(void) { 
....................    tiempo=get_timer1(); // 
*
0031:  MOVF   0F,W
0032:  MOVWF  7A
0033:  MOVF   0E,W
0034:  MOVWF  77
0035:  MOVF   0F,W
0036:  SUBWF  7A,W
0037:  BTFSS  03.2
0038:  GOTO   031
0039:  MOVF   77,W
003A:  MOVWF  28
003B:  MOVF   7A,W
003C:  MOVWF  29
....................    set_timer1(0); //reinicia para nuevo pulso 
003D:  CLRF   0F
003E:  CLRF   0E
.................... } 
....................  
003F:  BCF    0B.1
0040:  BCF    0A.3
0041:  GOTO   01E
.................... void init_freq(){ 
....................    ext_int_edge(0,L_TO_H); //Flanco ascendente 
0042:  BSF    03.5
0043:  BSF    01.6
....................    enable_interrupts(INT_EXT); 
0044:  BCF    03.5
0045:  BSF    0B.4
....................    clear_interrupt(INT_EXT); //Borramos el flag 
0046:  BCF    0B.1
....................    enable_interrupts(GLOBAL); 
0047:  MOVLW  C0
0048:  IORWF  0B,F
....................    setup_timer_1(T1_INTERNAL | T1_DIV_BY_4);//para llegar a medir frecuencias bajas 
0049:  MOVLW  A5
004A:  MOVWF  10
.................... } 
....................  
.................... int16 calcula_frecuencia(){ 
....................    int16 tiempo_cal; 
....................    int16 frecuencia; 
....................    tiempo_cal=tiempo*2; //Es 4ciclos*T*4 del preescaler*ELm timer 
*
0071:  BCF    03.0
0072:  RLF    28,W
0073:  MOVWF  3E
0074:  RLF    29,W
0075:  MOVWF  3F
....................    frecuencia=1000000.0/tiempo_cal; //esto es porque 1/(2N*micro)=(10^6)/2N 
0076:  MOVF   3F,W
0077:  MOVWF  43
0078:  MOVF   3E,W
0079:  MOVWF  42
*
0096:  CLRF   45
0097:  MOVLW  24
0098:  MOVWF  44
0099:  MOVLW  74
009A:  MOVWF  43
009B:  MOVLW  92
009C:  MOVWF  42
009D:  MOVF   7A,W
009E:  MOVWF  49
009F:  MOVF   79,W
00A0:  MOVWF  48
00A1:  MOVF   78,W
00A2:  MOVWF  47
00A3:  MOVF   77,W
00A4:  MOVWF  46
*
016E:  MOVF   7A,W
016F:  MOVWF  45
0170:  MOVF   79,W
0171:  MOVWF  44
0172:  MOVF   78,W
0173:  MOVWF  43
0174:  MOVF   77,W
0175:  MOVWF  42
*
0194:  MOVF   79,W
0195:  MOVWF  41
0196:  MOVF   78,W
0197:  MOVWF  40
....................    return frecuencia; 
0198:  MOVF   40,W
0199:  MOVWF  78
019A:  MOVF   41,W
019B:  MOVWF  79
.................... } 
019C:  RETURN
....................  
....................  
....................  
....................  
.................... #define S0 PIN_B1 
.................... #define S1 PIN_B2 
.................... #define S2 PIN_B6 
.................... #define S3 PIN_B4 
.................... #define OE PIN_B5 
....................  
.................... int8 offset_r=34; 
.................... int8 offset_g=0; 
.................... int8 offset_b=15; 
....................  
.................... //Habria que hacer una función "init_tcs" mas general para poder seleccionar otros rangos 
.................... void init_tcs(){ 
....................    init_freq(); 
....................    output_low(S0);// Para seleccionar el rango de 12 KHz 
*
004B:  BSF    03.5
004C:  BCF    06.1
004D:  BCF    03.5
004E:  BCF    06.1
....................    output_high(S1); 
004F:  BSF    03.5
0050:  BCF    06.2
0051:  BCF    03.5
0052:  BSF    06.2
.................... } 
0053:  BCF    0A.3
0054:  GOTO   286 (RETURN)
....................  
.................... void leer_frecuencia_color(int16 *frecuencia_R, int16 *frecuencia_G, int16 *frecuencia_B){ 
....................    output_high(OE); 
*
019D:  BSF    03.5
019E:  BCF    06.5
019F:  BCF    03.5
01A0:  BSF    06.5
....................    output_low(S2); 
01A1:  BSF    03.5
01A2:  BCF    06.6
01A3:  BCF    03.5
01A4:  BCF    06.6
....................    output_low(S3); 
01A5:  BSF    03.5
01A6:  BCF    06.4
01A7:  BCF    03.5
01A8:  BCF    06.4
....................     
....................    delay_ms(1); 
01A9:  MOVLW  01
01AA:  MOVWF  3C
01AB:  CALL   05D
....................    output_low(OE); 
01AC:  BSF    03.5
01AD:  BCF    06.5
01AE:  BCF    03.5
01AF:  BCF    06.5
....................    delay_ms(10); 
01B0:  MOVLW  0A
01B1:  MOVWF  3C
01B2:  CALL   05D
....................    *frecuencia_R=calcula_frecuencia()-offset_r; 
01B3:  MOVF   37,W
01B4:  MOVWF  7A
01B5:  MOVF   36,W
01B6:  MOVWF  3C
01B7:  MOVF   37,W
01B8:  MOVWF  3D
01B9:  CALL   071
01BA:  MOVF   2A,W
01BB:  SUBWF  78,W
01BC:  MOVWF  77
01BD:  MOVF   79,W
01BE:  MOVWF  7A
01BF:  MOVLW  00
01C0:  BTFSS  03.0
01C1:  MOVLW  01
01C2:  SUBWF  7A,F
01C3:  MOVF   3C,W
01C4:  MOVWF  04
01C5:  BCF    03.7
01C6:  BTFSC  3D.0
01C7:  BSF    03.7
01C8:  INCF   04,F
01C9:  MOVF   7A,W
01CA:  MOVWF  00
01CB:  DECF   04,F
01CC:  MOVF   77,W
01CD:  MOVWF  00
....................     
....................    //Azul 
....................    output_high(OE); 
01CE:  BSF    03.5
01CF:  BCF    06.5
01D0:  BCF    03.5
01D1:  BSF    06.5
....................    output_low(S2); 
01D2:  BSF    03.5
01D3:  BCF    06.6
01D4:  BCF    03.5
01D5:  BCF    06.6
....................    output_high(S3); 
01D6:  BSF    03.5
01D7:  BCF    06.4
01D8:  BCF    03.5
01D9:  BSF    06.4
....................     
....................    delay_ms(1); 
01DA:  MOVLW  01
01DB:  MOVWF  3C
01DC:  CALL   05D
....................    output_low(OE); 
01DD:  BSF    03.5
01DE:  BCF    06.5
01DF:  BCF    03.5
01E0:  BCF    06.5
....................    delay_ms(10); 
01E1:  MOVLW  0A
01E2:  MOVWF  3C
01E3:  CALL   05D
....................    *frecuencia_B=calcula_frecuencia()-offset_b; 
01E4:  MOVF   3B,W
01E5:  MOVWF  7A
01E6:  MOVF   3A,W
01E7:  MOVWF  3C
01E8:  MOVF   3B,W
01E9:  MOVWF  3D
01EA:  CALL   071
01EB:  MOVF   2C,W
01EC:  SUBWF  78,W
01ED:  MOVWF  77
01EE:  MOVF   79,W
01EF:  MOVWF  7A
01F0:  MOVLW  00
01F1:  BTFSS  03.0
01F2:  MOVLW  01
01F3:  SUBWF  7A,F
01F4:  MOVF   3C,W
01F5:  MOVWF  04
01F6:  BCF    03.7
01F7:  BTFSC  3D.0
01F8:  BSF    03.7
01F9:  INCF   04,F
01FA:  MOVF   7A,W
01FB:  MOVWF  00
01FC:  DECF   04,F
01FD:  MOVF   77,W
01FE:  MOVWF  00
....................     
....................    //Verde 
....................    output_high(OE); 
01FF:  BSF    03.5
0200:  BCF    06.5
0201:  BCF    03.5
0202:  BSF    06.5
....................    output_high(S2); 
0203:  BSF    03.5
0204:  BCF    06.6
0205:  BCF    03.5
0206:  BSF    06.6
....................    output_high(S3); 
0207:  BSF    03.5
0208:  BCF    06.4
0209:  BCF    03.5
020A:  BSF    06.4
....................     
....................    delay_ms(1); 
020B:  MOVLW  01
020C:  MOVWF  3C
020D:  CALL   05D
....................    output_low(OE); 
020E:  BSF    03.5
020F:  BCF    06.5
0210:  BCF    03.5
0211:  BCF    06.5
....................    delay_ms(10); 
0212:  MOVLW  0A
0213:  MOVWF  3C
0214:  CALL   05D
....................    *frecuencia_G=calcula_frecuencia()-offset_g; 
0215:  MOVF   39,W
0216:  MOVWF  7A
0217:  MOVF   38,W
0218:  MOVWF  3C
0219:  MOVF   39,W
021A:  MOVWF  3D
021B:  CALL   071
021C:  MOVF   2B,W
021D:  SUBWF  78,W
021E:  MOVWF  77
021F:  MOVF   79,W
0220:  MOVWF  7A
0221:  MOVLW  00
0222:  BTFSS  03.0
0223:  MOVLW  01
0224:  SUBWF  7A,F
0225:  MOVF   3C,W
0226:  MOVWF  04
0227:  BCF    03.7
0228:  BTFSC  3D.0
0229:  BSF    03.7
022A:  INCF   04,F
022B:  MOVF   7A,W
022C:  MOVWF  00
022D:  DECF   04,F
022E:  MOVF   77,W
022F:  MOVWF  00
.................... } 
0230:  BCF    0A.3
0231:  GOTO   291 (RETURN)
....................  
....................  
.................... //COLOR2MUSIC 
.................... //Autor: Nicolás Guerrero García (Nitehack) 
.................... //Resumen: Transforma un sonido físico a una nota músical, pudiendo así generar musica con diferentes objetos de diferentes colores. 
....................  
....................  
....................  
.................... //ANOTACIONES: 
.................... //Hay que poner el máximo de frecuencia para medir tiempos muy cortos y el minimo de 
.................... // rango para que el error para medir la frecuencia con el metodo de medir 
.................... // el periodo sea minimo ya que falla solo cuando son muy altas las frecuencias 
.................... //Preescaler de 4 con minimo de 7 Hz 
.................... // Si se desborda el timer poner una interrupcion y poner de frecuencia 0Hz 
.................... //Poner reloj de 20 MHz externo 
.................... //Al final el reloj va a ser el de 8 MHz interno 
.................... // Se puede poner un umbral para considerar colo o no 
....................  
.................... //Informacion 
.................... //----------- 
.................... // Con 12 KHz 
.................... //Maxima frecuencia para R: 13157 Hz  
.................... //Maxima frecuencia para B: 13157 Hz (En hexadecimal 3365 Hz) 
.................... // Maxima frecuencia para G:  11111 Hz (En hexadecimal 2B67) 
.................... //MinimaR:169 Hz (A9) 
.................... // Minima G: 135 Hz (87) 
.................... //Minima B: 150 Hz (96) 
....................  
.................... //Que hay que hacer: 
.................... //------------------ 
.................... //Corregir error de 0 y de ganancia para los 3 filtros 
.................... //Posibles problemas!!:  
.................... //---------------------- 
.................... //Que el contador del timer se desborde por que pase demasiado tiempo , es decir cuando sean bajas frecuencias 
.................... // 
.................... //Sonido 
.................... //------ 
.................... //Espectro de frecuencias de sonido: 30 Hz a 15 KHz 
.................... //PeridoPWM= (periodo_TMR2+1)·4·Tosc· prescaler_TMR2 
.................... //Hay que poner el preescaler el mas alto (16) ya que buscamos el myor rango entre 30 y 15 KHz, y para conseguir 
.................... //He usado desde 523 Hz hasta 980 Hz, y se puede usar un total de 12 notas 
....................  
....................  
.................... //Para corregir el offset del sensor 
....................  
.................... //Capturar flanco-> contar tiempo-> Capturar flanco-> Parar tiempo-> Leer tiempo-> Cambiar a frecuencia 
....................  
....................  
.................... void main() 
.................... { 
*
0263:  CLRF   04
0264:  BCF    03.7
0265:  MOVLW  1F
0266:  ANDWF  03,F
0267:  MOVLW  72
0268:  BSF    03.5
0269:  MOVWF  0F
026A:  MOVF   0F,W
026B:  BCF    03.5
026C:  CLRF   29
026D:  CLRF   28
026E:  MOVLW  22
026F:  MOVWF  2A
0270:  CLRF   2B
0271:  MOVLW  0F
0272:  MOVWF  2C
0273:  BSF    03.5
0274:  BCF    1F.4
0275:  BCF    1F.5
0276:  MOVF   1B,W
0277:  ANDLW  80
0278:  MOVWF  1B
0279:  MOVLW  07
027A:  MOVWF  1C
027B:  BCF    03.5
027C:  CLRF   2E
027D:  CLRF   2D
027E:  CLRF   30
027F:  CLRF   2F
0280:  CLRF   32
0281:  CLRF   31
0282:  CLRF   33
0283:  CLRF   34
0284:  CLRF   35
....................    int16 frecuencia_R=0; 
....................    int16 frecuencia_G=0; 
....................    int16 frecuencia_B=0; 
....................    int8 dato=0; 
....................    int8 maximo=0; 
....................    int8 direccion=0; 
....................  
.................... //Configuracion 
.................... //!   ext_int_edge(0,L_TO_H); //Flanco ascendente 
.................... //!   enable_interrupts(INT_EXT); 
.................... //!   clear_interrupt(INT_EXT); //Borramos el flag 
.................... //!   enable_interrupts(GLOBAL); 
.................... //!   setup_timer_1(T1_INTERNAL | T1_DIV_BY_4);//para llegar a medir frecuencias bajas 
.................... //! 
.................... // 
....................     
....................    init_tcs(); 
0285:  GOTO   042
....................    init_sound(); 
0286:  GOTO   055
....................     
....................    while(true){ 
....................       leer_frecuencia_color(&frecuencia_R,&frecuencia_G, &frecuencia_B); 
0287:  CLRF   37
0288:  MOVLW  2D
0289:  MOVWF  36
028A:  CLRF   39
028B:  MOVLW  2F
028C:  MOVWF  38
028D:  CLRF   3B
028E:  MOVLW  31
028F:  MOVWF  3A
0290:  GOTO   19D
....................       frecuencia_R=frecuencia_R-offset_r; 
0291:  MOVF   2A,W
0292:  SUBWF  2D,F
0293:  MOVLW  00
0294:  BTFSS  03.0
0295:  MOVLW  01
0296:  SUBWF  2E,F
....................       frecuencia_G=frecuencia_G-offset_g; 
0297:  MOVF   2B,W
0298:  SUBWF  2F,F
0299:  MOVLW  00
029A:  BTFSS  03.0
029B:  MOVLW  01
029C:  SUBWF  30,F
....................       frecuencia_B=frecuencia_B-offset_b; 
029D:  MOVF   2C,W
029E:  SUBWF  31,F
029F:  MOVLW  00
02A0:  BTFSS  03.0
02A1:  MOVLW  01
02A2:  SUBWF  32,F
....................        
....................       dato=(int8)(frecuencia_R>>8); 
02A3:  MOVF   2E,W
02A4:  CLRF   7A
02A5:  MOVWF  33
....................       write_eeprom(direccion, dato); 
02A6:  MOVF   35,W
02A7:  BSF    03.6
02A8:  MOVWF  0D
02A9:  BCF    03.6
02AA:  MOVF   33,W
02AB:  BSF    03.6
02AC:  MOVWF  0C
02AD:  BSF    03.5
02AE:  BCF    0C.7
02AF:  BSF    0C.2
02B0:  BCF    03.5
02B1:  BCF    03.6
02B2:  MOVF   0B,W
02B3:  MOVWF  77
02B4:  BCF    0B.7
02B5:  BSF    03.5
02B6:  BSF    03.6
02B7:  MOVLW  55
02B8:  MOVWF  0D
02B9:  MOVLW  AA
02BA:  MOVWF  0D
02BB:  BSF    0C.1
02BC:  BTFSC  0C.1
02BD:  GOTO   2BC
02BE:  BCF    0C.2
02BF:  MOVF   77,W
02C0:  BCF    03.5
02C1:  BCF    03.6
02C2:  IORWF  0B,F
....................       dato=(int8)(frecuencia_R); 
02C3:  MOVF   2D,W
02C4:  MOVWF  33
....................       write_eeprom(direccion+1, dato); 
02C5:  MOVLW  01
02C6:  ADDWF  35,W
02C7:  MOVWF  36
02C8:  MOVF   36,W
02C9:  BSF    03.6
02CA:  MOVWF  0D
02CB:  BCF    03.6
02CC:  MOVF   33,W
02CD:  BSF    03.6
02CE:  MOVWF  0C
02CF:  BSF    03.5
02D0:  BCF    0C.7
02D1:  BSF    0C.2
02D2:  BCF    03.5
02D3:  BCF    03.6
02D4:  MOVF   0B,W
02D5:  MOVWF  77
02D6:  BCF    0B.7
02D7:  BSF    03.5
02D8:  BSF    03.6
02D9:  MOVLW  55
02DA:  MOVWF  0D
02DB:  MOVLW  AA
02DC:  MOVWF  0D
02DD:  BSF    0C.1
02DE:  BTFSC  0C.1
02DF:  GOTO   2DE
02E0:  BCF    0C.2
02E1:  MOVF   77,W
02E2:  BCF    03.5
02E3:  BCF    03.6
02E4:  IORWF  0B,F
....................        
....................       dato=(int8)(frecuencia_G>>8); 
02E5:  MOVF   30,W
02E6:  CLRF   7A
02E7:  MOVWF  33
....................       write_eeprom(direccion+2, dato); 
02E8:  MOVLW  02
02E9:  ADDWF  35,W
02EA:  MOVWF  36
02EB:  MOVF   36,W
02EC:  BSF    03.6
02ED:  MOVWF  0D
02EE:  BCF    03.6
02EF:  MOVF   33,W
02F0:  BSF    03.6
02F1:  MOVWF  0C
02F2:  BSF    03.5
02F3:  BCF    0C.7
02F4:  BSF    0C.2
02F5:  BCF    03.5
02F6:  BCF    03.6
02F7:  MOVF   0B,W
02F8:  MOVWF  77
02F9:  BCF    0B.7
02FA:  BSF    03.5
02FB:  BSF    03.6
02FC:  MOVLW  55
02FD:  MOVWF  0D
02FE:  MOVLW  AA
02FF:  MOVWF  0D
0300:  BSF    0C.1
0301:  BTFSC  0C.1
0302:  GOTO   301
0303:  BCF    0C.2
0304:  MOVF   77,W
0305:  BCF    03.5
0306:  BCF    03.6
0307:  IORWF  0B,F
....................       dato=(int8)(frecuencia_G); 
0308:  MOVF   2F,W
0309:  MOVWF  33
....................       write_eeprom(direccion+3, dato); 
030A:  MOVLW  03
030B:  ADDWF  35,W
030C:  MOVWF  36
030D:  MOVF   36,W
030E:  BSF    03.6
030F:  MOVWF  0D
0310:  BCF    03.6
0311:  MOVF   33,W
0312:  BSF    03.6
0313:  MOVWF  0C
0314:  BSF    03.5
0315:  BCF    0C.7
0316:  BSF    0C.2
0317:  BCF    03.5
0318:  BCF    03.6
0319:  MOVF   0B,W
031A:  MOVWF  77
031B:  BCF    0B.7
031C:  BSF    03.5
031D:  BSF    03.6
031E:  MOVLW  55
031F:  MOVWF  0D
0320:  MOVLW  AA
0321:  MOVWF  0D
0322:  BSF    0C.1
0323:  BTFSC  0C.1
0324:  GOTO   323
0325:  BCF    0C.2
0326:  MOVF   77,W
0327:  BCF    03.5
0328:  BCF    03.6
0329:  IORWF  0B,F
....................        
....................       dato=(int8)(frecuencia_B>>8); 
032A:  MOVF   32,W
032B:  CLRF   7A
032C:  MOVWF  33
....................       write_eeprom(direccion+4, dato); 
032D:  MOVLW  04
032E:  ADDWF  35,W
032F:  MOVWF  36
0330:  MOVF   36,W
0331:  BSF    03.6
0332:  MOVWF  0D
0333:  BCF    03.6
0334:  MOVF   33,W
0335:  BSF    03.6
0336:  MOVWF  0C
0337:  BSF    03.5
0338:  BCF    0C.7
0339:  BSF    0C.2
033A:  BCF    03.5
033B:  BCF    03.6
033C:  MOVF   0B,W
033D:  MOVWF  77
033E:  BCF    0B.7
033F:  BSF    03.5
0340:  BSF    03.6
0341:  MOVLW  55
0342:  MOVWF  0D
0343:  MOVLW  AA
0344:  MOVWF  0D
0345:  BSF    0C.1
0346:  BTFSC  0C.1
0347:  GOTO   346
0348:  BCF    0C.2
0349:  MOVF   77,W
034A:  BCF    03.5
034B:  BCF    03.6
034C:  IORWF  0B,F
....................       dato=(int8)(frecuencia_B); 
034D:  MOVF   31,W
034E:  MOVWF  33
....................       write_eeprom(direccion+5, dato); 
034F:  MOVLW  05
0350:  ADDWF  35,W
0351:  MOVWF  36
0352:  MOVF   36,W
0353:  BSF    03.6
0354:  MOVWF  0D
0355:  BCF    03.6
0356:  MOVF   33,W
0357:  BSF    03.6
0358:  MOVWF  0C
0359:  BSF    03.5
035A:  BCF    0C.7
035B:  BSF    0C.2
035C:  BCF    03.5
035D:  BCF    03.6
035E:  MOVF   0B,W
035F:  MOVWF  77
0360:  BCF    0B.7
0361:  BSF    03.5
0362:  BSF    03.6
0363:  MOVLW  55
0364:  MOVWF  0D
0365:  MOVLW  AA
0366:  MOVWF  0D
0367:  BSF    0C.1
0368:  BTFSC  0C.1
0369:  GOTO   368
036A:  BCF    0C.2
036B:  MOVF   77,W
036C:  BCF    03.5
036D:  BCF    03.6
036E:  IORWF  0B,F
....................        
....................       direccion=direccion+7; 
036F:  MOVLW  07
0370:  ADDWF  35,F
....................        
....................       if((frecuencia_R<288)&&(frecuencia_G<208)&&(frecuencia_B<208)){ 
0371:  MOVF   2E,W
0372:  SUBLW  01
0373:  BTFSS  03.0
0374:  GOTO   38B
0375:  BTFSS  03.2
0376:  GOTO   37B
0377:  MOVF   2D,W
0378:  SUBLW  1F
0379:  BTFSS  03.0
037A:  GOTO   38B
037B:  MOVF   30,F
037C:  BTFSS  03.2
037D:  GOTO   38B
037E:  MOVF   2F,W
037F:  SUBLW  CF
0380:  BTFSS  03.0
0381:  GOTO   38B
0382:  MOVF   32,F
0383:  BTFSS  03.2
0384:  GOTO   38B
0385:  MOVF   31,W
0386:  SUBLW  CF
0387:  BTFSS  03.0
0388:  GOTO   38B
....................          maximo=0; 
0389:  CLRF   34
....................       } 
....................       else{ 
038A:  GOTO   3B4
....................          if(frecuencia_R>frecuencia_G){ 
038B:  MOVF   30,W
038C:  SUBWF  2E,W
038D:  BTFSS  03.0
038E:  GOTO   3A5
038F:  BTFSS  03.2
0390:  GOTO   395
0391:  MOVF   2D,W
0392:  SUBWF  2F,W
0393:  BTFSC  03.0
0394:  GOTO   3A5
....................             if(frecuencia_R>frecuencia_B){ 
0395:  MOVF   32,W
0396:  SUBWF  2E,W
0397:  BTFSS  03.0
0398:  GOTO   3A2
0399:  BTFSS  03.2
039A:  GOTO   39F
039B:  MOVF   2D,W
039C:  SUBWF  31,W
039D:  BTFSC  03.0
039E:  GOTO   3A2
....................                maximo=1; 
039F:  MOVLW  01
03A0:  MOVWF  34
....................             } 
....................             else{ 
03A1:  GOTO   3A4
....................                maximo=3; 
03A2:  MOVLW  03
03A3:  MOVWF  34
....................             } 
....................          } 
....................          else{ 
03A4:  GOTO   3B4
....................             if(frecuencia_G>frecuencia_B){ 
03A5:  MOVF   32,W
03A6:  SUBWF  30,W
03A7:  BTFSS  03.0
03A8:  GOTO   3B2
03A9:  BTFSS  03.2
03AA:  GOTO   3AF
03AB:  MOVF   2F,W
03AC:  SUBWF  31,W
03AD:  BTFSC  03.0
03AE:  GOTO   3B2
....................                maximo=2; 
03AF:  MOVLW  02
03B0:  MOVWF  34
....................             } 
....................             else{ 
03B1:  GOTO   3B4
....................                maximo=3; 
03B2:  MOVLW  03
03B3:  MOVWF  34
....................             } 
....................          } 
....................       } 
....................       switch(maximo){ 
03B4:  MOVF   34,W
03B5:  XORLW  01
03B6:  BTFSC  03.2
03B7:  GOTO   3BF
03B8:  XORLW  03
03B9:  BTFSC  03.2
03BA:  GOTO   3CF
03BB:  XORLW  01
03BC:  BTFSC  03.2
03BD:  GOTO   3DF
03BE:  GOTO   3EF
....................          case 1: 
....................             output_low(PIN_A1); 
03BF:  BSF    03.5
03C0:  BCF    05.1
03C1:  BCF    03.5
03C2:  BCF    05.1
....................             output_low(PIN_A2); 
03C3:  BSF    03.5
03C4:  BCF    05.2
03C5:  BCF    03.5
03C6:  BCF    05.2
....................             output_high(PIN_A0); 
03C7:  BSF    03.5
03C8:  BCF    05.0
03C9:  BCF    03.5
03CA:  BSF    05.0
....................             genera_sonido(DOn); 
03CB:  MOVLW  EE
03CC:  MOVWF  36
03CD:  CALL   232
....................             break; 
03CE:  GOTO   3FF
....................          case 2: 
....................             output_low(PIN_A0); 
03CF:  BSF    03.5
03D0:  BCF    05.0
03D1:  BCF    03.5
03D2:  BCF    05.0
....................             output_low(PIN_A2); 
03D3:  BSF    03.5
03D4:  BCF    05.2
03D5:  BCF    03.5
03D6:  BCF    05.2
....................             output_high(PIN_A1); 
03D7:  BSF    03.5
03D8:  BCF    05.1
03D9:  BCF    03.5
03DA:  BSF    05.1
....................             genera_sonido(REn); 
03DB:  MOVLW  D4
03DC:  MOVWF  36
03DD:  CALL   232
....................             break; 
03DE:  GOTO   3FF
....................              
....................          case 3: 
....................             output_low(PIN_A0); 
03DF:  BSF    03.5
03E0:  BCF    05.0
03E1:  BCF    03.5
03E2:  BCF    05.0
....................             output_low(PIN_A1); 
03E3:  BSF    03.5
03E4:  BCF    05.1
03E5:  BCF    03.5
03E6:  BCF    05.1
....................             output_high(PIN_A2); 
03E7:  BSF    03.5
03E8:  BCF    05.2
03E9:  BCF    03.5
03EA:  BSF    05.2
....................             genera_sonido(MIn); 
03EB:  MOVLW  BD
03EC:  MOVWF  36
03ED:  CALL   232
....................             break; 
03EE:  GOTO   3FF
....................          default: 
....................             output_low(PIN_A0); 
03EF:  BSF    03.5
03F0:  BCF    05.0
03F1:  BCF    03.5
03F2:  BCF    05.0
....................             output_low(PIN_A1); 
03F3:  BSF    03.5
03F4:  BCF    05.1
03F5:  BCF    03.5
03F6:  BCF    05.1
....................             output_low(PIN_A2); 
03F7:  BSF    03.5
03F8:  BCF    05.2
03F9:  BCF    03.5
03FA:  BCF    05.2
....................             genera_sonido(FAn); 
03FB:  MOVLW  B2
03FC:  MOVWF  36
03FD:  CALL   232
....................             break; 
03FE:  GOTO   3FF
....................       } 
....................       if (direccion>=240){ 
03FF:  MOVF   35,W
0400:  SUBLW  EF
0401:  BTFSC  03.0
0402:  GOTO   404
....................          direccion=0; 
0403:  CLRF   35
....................       } 
....................    } 
0404:  GOTO   287
....................     
.................... } 
0405:  SLEEP

Configuration Fuses:
   Word  1: 2F38   NOWDT NOPUT MCLR NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG CCPB3 NOPROTECT INTRC_IO
   Word  2: 3FFF   FCMEN IESO
